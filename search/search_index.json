{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to aegis documentation! aegis provides endpoint protection and authentication scoping for aiohttp. Installation pip install aegis Bare Minimum Examples Basic Authentication from aiohttp import web from aegis import login_required , BasicAuth class BasicAuthenticator ( BasicAuth ): async def authenticate ( self , request : web . Request ) -> dict : return {} @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) app = web . Application () app . router . add_get ( '/' , protected ) BasicAuthenticator . setup ( app ) web . run_app ( app ) JWT Authentication from aiohttp import web from aegis import login_required , JWTAuth class JWTAuthenticator ( JWTAuth ): jwt_secret = \"<secret>\" async def authenticate ( self , request : web . Request ) -> dict : return {} @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) app = web . Application () app . router . add_get ( '/' , protected ) JWTAuthenticator . setup ( app ) web . run_app ( app ) Source code The project is hosted on GitHub: https://github.com/mgurdal/aegis Please feel free to file an issue on the bug tracker if you have found a bug or have some suggestion in order to improve the library. Author and License The aegis package is written by Mehmet G\u00fcrdal. It's Apache 2 licensed and freely available.","title":"Home"},{"location":"#welcome-to-aegis-documentation","text":"aegis provides endpoint protection and authentication scoping for aiohttp.","title":"Welcome to aegis documentation!"},{"location":"#installation","text":"pip install aegis","title":"Installation"},{"location":"#bare-minimum-examples","text":"","title":"Bare Minimum Examples"},{"location":"#basic-authentication","text":"from aiohttp import web from aegis import login_required , BasicAuth class BasicAuthenticator ( BasicAuth ): async def authenticate ( self , request : web . Request ) -> dict : return {} @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) app = web . Application () app . router . add_get ( '/' , protected ) BasicAuthenticator . setup ( app ) web . run_app ( app )","title":"Basic Authentication"},{"location":"#jwt-authentication","text":"from aiohttp import web from aegis import login_required , JWTAuth class JWTAuthenticator ( JWTAuth ): jwt_secret = \"<secret>\" async def authenticate ( self , request : web . Request ) -> dict : return {} @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) app = web . Application () app . router . add_get ( '/' , protected ) JWTAuthenticator . setup ( app ) web . run_app ( app )","title":"JWT Authentication"},{"location":"#source-code","text":"The project is hosted on GitHub: https://github.com/mgurdal/aegis Please feel free to file an issue on the bug tracker if you have found a bug or have some suggestion in order to improve the library.","title":"Source code"},{"location":"#author-and-license","text":"The aegis package is written by Mehmet G\u00fcrdal. It's Apache 2 licensed and freely available.","title":"Author and License"},{"location":"authenticators/","text":"Authenticators Default authenticators. BasicAuth aegis.authenticators.basic.BasicAuth Base authenticator for Basic authentication. Authenticator is set-up by setup() . The class implements aegis.authenticators.base.BaseAuth . User should never instantiate the class but create a new class that inherits and overrides required variables and methods. user_id , password and authenticate is forced to override. Arguments : me_endpoint - User information endpoint URI. Default route is /me . auth_endpoint - End-point URI for authenticating the user. If user sends a POST request to this end-point it triggers the authenticate method. Default route is None since we do not need an authentication end-point in Basic authentication. user_id: str - The key name to retain the user ID when the token is decoded. Default value is user_id . password: str - The key name to retain the password when the token is decoded. Default value is password . Methods : decode(jwt_token: str, verify=True) -> dict Decode basic token and return user's id and password as a dict. Exceptions : InvalidTokenException will be raised if base64.b64decode fails to decode the token. get_permissions(request: web.Request) Get the user from the request and return user's permissions. authenticate(self, request: web.Request) -> Dict[str, Any] Return JSON serializable user. This is an abstract method and should be overridden. classmethod setup(app, name='authenticator') Set-up the authenticator. JWTAuth aegis.authenticators.jwt.JWTAuth Base authenticator for JSON Web Token authentication. Authenticator is set-up by :meth: setup . The class implements :class: aegis.authenticators.base.BaseAuth . User should never instantiate the class but create a new class that inherits and overrides required variables and methods. :attr: jwt_secret and :meth: authenticator is forced to override. Arguments : jwt_secret: str - The secret key for encoding and decoding unique tokens. duration: int - Access token expiration limit. Default limit is 25_000 . jwt_algorithm: str - The algorithm that will be used to generate the tokens. Default algorithm is HS256 . refresh_token: bool - The flag that activates the refresh token feature. Default value is False . refresh_endpoint: str - Token refreshing endpoint URI. Default route is /auth/refresh . Methods : decode(jwt_token: str, verify=True) -> dict Decode the given token and return as a dict . Raise validation exceptions if verify is set to True . Exceptions : InvalidTokenException will be raised if PyJWT fails to decode the access token. TokenExpiredException will be raised if access token has expired. encode(payload: dict) -> str Encode given payload and return as a string. get_permissions(request: web.Request) Get the user from the request and return user's permissions. authenticate(self, request: web.Request) -> Dict[str, Any] Return JSON serializable user. This is an abstract method and should be overridden. classmethod setup(app, name='authenticator') Set-up the authenticator. BaseAuth aegis.authenticators.base.BaseAuth Abstract base authenticator. User can implement new authenticators based on their needs. Arguments : me_endpoint - User information endpoint URI. Default route is /me . auth_endpoint - End-point URI for authenticating the user. If user sends a POST request to this end-point it triggers the :meth: authenticate method. Default route is /auth . Methods : check_permissions(user_scopes, required_scopes, algorithm='any') -> bool Check whether user's permissions matches with required permissions to reach to the end-point. By default check_permissions uses the any algorithm opens the end-point for any user who has any of the required permissions. We can use other pre-defined algorithms. algorithm='all' opens the end-point to users who has all of the required permissions. End-point will also be open for users with more permissions than its required with all algorithm. If you want to open the end-point for the users who have exactly the same permissions with the end-point` you can use the algorithm='exact' . abstractmethod decode(jwt_token: str, verify=True) -> dict Decode token and return user credentials as a dict. This is an abstract method and should be overridden. abstractmethod get_permissions(request: web.Request) Decode token and return user credentials as a dict. This is an abstract method and should be overridden. abstractmethod authenticate(self, request: web.Request) -> Dict[str, Any] Return JSON serializable user. This is an abstract method and should be overridden. classmethod setup(app, name='authenticator') Set-up the authenticator. MockAuthenticator aegis.test_utils.MockAuthenticator MockAuthenticator has an almost identical API to default authenticator classes. You can use this authenticator in your unit tests to bypass the authentication logic. class AppTestCase ( AioHTTPTestCase ): async def get_application ( self ): app = create_app () MockAuthenticator . setup ( app ) return app By calling the setup method, MockAuthenticator will mock the authenticator that you have been using in your app. MockAuthenticator is almost the same with the previous authenticator. In addition, it also has some extra features to bypass the authentication system. Arguments : user - Injected test user. Default is None . Methods : bypass_auth(user: dict) bypass_auth might be the only method you will ever need to control the authentication logic. It is a contextmanager . So you can disable the permission control multiple times in your test suite. To use the bypass_auth , we first need to reach to our mocked authenticator instance, and then, we can manipulate the authentication control by calling the bypass_auth method with a test user. @unittest_run_loop async def test_protected_route_without_credentials ( self ): mocked_authenticator = self . app [ \"authenticator\" ] mock_user = { \"permissions\" : ( \"user\" ,)} with mocked_authenticator . bypass_auth ( user = mock_user ): resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 200 resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 401 classmethod setup(app) Set-up the authenticator with mocked features. class AppTestCase ( AioHTTPTestCase ): async def get_application ( self ): app = create_app () MockAuthenticator . setup ( app ) return app","title":"Authenticators"},{"location":"authenticators/#authenticators","text":"Default authenticators.","title":"Authenticators"},{"location":"authenticators/#basicauth","text":"aegis.authenticators.basic.BasicAuth Base authenticator for Basic authentication. Authenticator is set-up by setup() . The class implements aegis.authenticators.base.BaseAuth . User should never instantiate the class but create a new class that inherits and overrides required variables and methods. user_id , password and authenticate is forced to override. Arguments : me_endpoint - User information endpoint URI. Default route is /me . auth_endpoint - End-point URI for authenticating the user. If user sends a POST request to this end-point it triggers the authenticate method. Default route is None since we do not need an authentication end-point in Basic authentication. user_id: str - The key name to retain the user ID when the token is decoded. Default value is user_id . password: str - The key name to retain the password when the token is decoded. Default value is password . Methods : decode(jwt_token: str, verify=True) -> dict Decode basic token and return user's id and password as a dict. Exceptions : InvalidTokenException will be raised if base64.b64decode fails to decode the token. get_permissions(request: web.Request) Get the user from the request and return user's permissions. authenticate(self, request: web.Request) -> Dict[str, Any] Return JSON serializable user. This is an abstract method and should be overridden. classmethod setup(app, name='authenticator') Set-up the authenticator.","title":"BasicAuth"},{"location":"authenticators/#jwtauth","text":"aegis.authenticators.jwt.JWTAuth Base authenticator for JSON Web Token authentication. Authenticator is set-up by :meth: setup . The class implements :class: aegis.authenticators.base.BaseAuth . User should never instantiate the class but create a new class that inherits and overrides required variables and methods. :attr: jwt_secret and :meth: authenticator is forced to override. Arguments : jwt_secret: str - The secret key for encoding and decoding unique tokens. duration: int - Access token expiration limit. Default limit is 25_000 . jwt_algorithm: str - The algorithm that will be used to generate the tokens. Default algorithm is HS256 . refresh_token: bool - The flag that activates the refresh token feature. Default value is False . refresh_endpoint: str - Token refreshing endpoint URI. Default route is /auth/refresh . Methods : decode(jwt_token: str, verify=True) -> dict Decode the given token and return as a dict . Raise validation exceptions if verify is set to True . Exceptions : InvalidTokenException will be raised if PyJWT fails to decode the access token. TokenExpiredException will be raised if access token has expired. encode(payload: dict) -> str Encode given payload and return as a string. get_permissions(request: web.Request) Get the user from the request and return user's permissions. authenticate(self, request: web.Request) -> Dict[str, Any] Return JSON serializable user. This is an abstract method and should be overridden. classmethod setup(app, name='authenticator') Set-up the authenticator.","title":"JWTAuth"},{"location":"authenticators/#baseauth","text":"aegis.authenticators.base.BaseAuth Abstract base authenticator. User can implement new authenticators based on their needs. Arguments : me_endpoint - User information endpoint URI. Default route is /me . auth_endpoint - End-point URI for authenticating the user. If user sends a POST request to this end-point it triggers the :meth: authenticate method. Default route is /auth . Methods : check_permissions(user_scopes, required_scopes, algorithm='any') -> bool Check whether user's permissions matches with required permissions to reach to the end-point. By default check_permissions uses the any algorithm opens the end-point for any user who has any of the required permissions. We can use other pre-defined algorithms. algorithm='all' opens the end-point to users who has all of the required permissions. End-point will also be open for users with more permissions than its required with all algorithm. If you want to open the end-point for the users who have exactly the same permissions with the end-point` you can use the algorithm='exact' . abstractmethod decode(jwt_token: str, verify=True) -> dict Decode token and return user credentials as a dict. This is an abstract method and should be overridden. abstractmethod get_permissions(request: web.Request) Decode token and return user credentials as a dict. This is an abstract method and should be overridden. abstractmethod authenticate(self, request: web.Request) -> Dict[str, Any] Return JSON serializable user. This is an abstract method and should be overridden. classmethod setup(app, name='authenticator') Set-up the authenticator.","title":"BaseAuth"},{"location":"authenticators/#mockauthenticator","text":"aegis.test_utils.MockAuthenticator MockAuthenticator has an almost identical API to default authenticator classes. You can use this authenticator in your unit tests to bypass the authentication logic. class AppTestCase ( AioHTTPTestCase ): async def get_application ( self ): app = create_app () MockAuthenticator . setup ( app ) return app By calling the setup method, MockAuthenticator will mock the authenticator that you have been using in your app. MockAuthenticator is almost the same with the previous authenticator. In addition, it also has some extra features to bypass the authentication system. Arguments : user - Injected test user. Default is None . Methods : bypass_auth(user: dict) bypass_auth might be the only method you will ever need to control the authentication logic. It is a contextmanager . So you can disable the permission control multiple times in your test suite. To use the bypass_auth , we first need to reach to our mocked authenticator instance, and then, we can manipulate the authentication control by calling the bypass_auth method with a test user. @unittest_run_loop async def test_protected_route_without_credentials ( self ): mocked_authenticator = self . app [ \"authenticator\" ] mock_user = { \"permissions\" : ( \"user\" ,)} with mocked_authenticator . bypass_auth ( user = mock_user ): resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 200 resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 401 classmethod setup(app) Set-up the authenticator with mocked features. class AppTestCase ( AioHTTPTestCase ): async def get_application ( self ): app = create_app () MockAuthenticator . setup ( app ) return app","title":"MockAuthenticator"},{"location":"decorators/","text":"Decorators Login and permission decorators. login_required aegis.decorators.login_required If unauthorized user tries to reach to a login_required end-point returns UNAUTHORIZED response. # server from aegis import login_required @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) app . router . add_get ( '/protected' , protected ) # client response = await session . get ( \"http://0.0.0.0:8080/protected\" ) assert response . status == 401 error = await response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#AuthRequiredException\" , \"title\" : \"Authentication Required\" , \"detail\" : \"You did not specify the required token in headers or you provided it incorrectly.\" , \"instance\" : \"http://0.0.0.0:8080/protected\" , \"status\" : \"401\" } permissions aegis.decorators.permissions Opens the end-point for any user who has the permission to access. Matching Algorithms : algorithm='any' - The default algorithm which opens the end-point for any user who has any of the required permissons. algorithm='all' - Opens the end-point to users who has all of the required permissons. In this case end-point is also open for users who has a superset of required permissions. algorithm='exact' - Opens the end-point for the users who has exactly the same permissions with required permissions. You can also implement your own matching algorithm and use with permissions. from aegis import permissions from aegis.matching_algorithms import match_any def match_any_and_admin ( required_permissions , user_permissions ) -> bool : # ignore the matching algorithm if user is admin has_permission = ( \"admin\" in user_permissions or match_any ( required_permissions , user_permissions ) ) return has_permission @permissions ( \"user\" , algorithm = match_any_and_admin ) async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) If user has no permission to access to scoped end-point, returns FORBIDDEN response. response = await session . get ( \"http://0.0.0.0:8080/protected\" ) assert response . status == 401 error = await response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#ForbiddenException\" , \"title\" : \"Forbidden Access\" , \"detail\" : \"User permissions does not meet access requests for http://0.0.0.0:8080/protected\" , \"instance\" : \"http://0.0.0.0:8080/protected\" , \"status\" : \"403\" }","title":"Decorators"},{"location":"decorators/#decorators","text":"Login and permission decorators.","title":"Decorators"},{"location":"decorators/#login_required","text":"aegis.decorators.login_required If unauthorized user tries to reach to a login_required end-point returns UNAUTHORIZED response. # server from aegis import login_required @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) app . router . add_get ( '/protected' , protected ) # client response = await session . get ( \"http://0.0.0.0:8080/protected\" ) assert response . status == 401 error = await response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#AuthRequiredException\" , \"title\" : \"Authentication Required\" , \"detail\" : \"You did not specify the required token in headers or you provided it incorrectly.\" , \"instance\" : \"http://0.0.0.0:8080/protected\" , \"status\" : \"401\" }","title":"login_required"},{"location":"decorators/#permissions","text":"aegis.decorators.permissions Opens the end-point for any user who has the permission to access. Matching Algorithms : algorithm='any' - The default algorithm which opens the end-point for any user who has any of the required permissons. algorithm='all' - Opens the end-point to users who has all of the required permissons. In this case end-point is also open for users who has a superset of required permissions. algorithm='exact' - Opens the end-point for the users who has exactly the same permissions with required permissions. You can also implement your own matching algorithm and use with permissions. from aegis import permissions from aegis.matching_algorithms import match_any def match_any_and_admin ( required_permissions , user_permissions ) -> bool : # ignore the matching algorithm if user is admin has_permission = ( \"admin\" in user_permissions or match_any ( required_permissions , user_permissions ) ) return has_permission @permissions ( \"user\" , algorithm = match_any_and_admin ) async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) If user has no permission to access to scoped end-point, returns FORBIDDEN response. response = await session . get ( \"http://0.0.0.0:8080/protected\" ) assert response . status == 401 error = await response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#ForbiddenException\" , \"title\" : \"Forbidden Access\" , \"detail\" : \"User permissions does not meet access requests for http://0.0.0.0:8080/protected\" , \"instance\" : \"http://0.0.0.0:8080/protected\" , \"status\" : \"403\" }","title":"permissions"},{"location":"exceptions/","text":"Exceptions Pre-defined authentication and authorization exceptions. AuthRequiredException aegis.exceptions.AuthRequiredException Raise exception if user tries to reach to a protected route without credentials. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import AuthRequiredException schema = AuthRequiredException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#AuthRequiredException\" , \"title\" : \"Authentication Required\" , \"detail\" : \"You did not specify the required token information in headers or you provided it incorrectly.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" } InvalidTokenException aegis.exceptions.InvalidTokenException Raise exception if user uses an invalid access token. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import InvalidTokenException schema = InvalidTokenException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#InvalidTokenException\" , \"title\" : \"Invalid Token\" , \"detail\" : \"You have provided an invalid token signature.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" } TokenExpiredException aegis.exceptions.TokenExpiredException Raise exception if user uses an expired access token. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import TokenExpiredException schema = TokenExpiredException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#TokenExpiredException\" , \"title\" : \"Invalid Token\" , \"detail\" : \"The access token provided has expired.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" } InvalidRefreshTokenException aegis.exceptions.InvalidRefreshTokenException Raise exception if user uses an invalid refresh token. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import InvalidRefreshTokenException schema = InvalidRefreshTokenException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#InvalidRefreshTokenException\" , \"title\" : \"Invalid Token\" , \"detail\" : \"You have provided an invalid refresh token.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" } AuthenticationFailedException aegis.exceptions.AuthenticationFailedException Raise exception if user tries to authenticate with invalid credentials. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import AuthenticationFailedException schema = AuthenticationFailedException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#AuthenticationFailedException\" , \"title\" : \"Authentication Failed\" , \"detail\" : \"The credentials you supplied were not correct.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" } ForbiddenException aegis.exceptions.ForbiddenException Raise exception if user tries to reach to an end-point without permissions. Attributes : status: 403 - Exception will create an FORBIDDEN response. Methods : staticmethod get_schema() -> dict from aegis import ForbiddenException schema = ForbiddenException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#ForbiddenException\" , \"title\" : \"Forbidden Access\" , \"detail\" : \"User permissions does not meet access requests for {url} \" , \"instance\" : \" {url} \" , \"status\" : \"403\" } AuthException aegis.exceptions.AuthException Base authentication exception. It is not recommended create instances directly from AuthException . Instead, inherit from AuthException and override status code and get_schema method for understandable responses. User should never instantiate the class but create a new class that inherits and overrides required variables and methods. user_id , password and authenticate is forced to override. Attributes : status: int - The HTTP status code that will be used when the error response is sent. Methods : classmethod make_response(cls, request: web.Request) Create a response based on exception schema. staticmethod get_schema() -> dict Return response payload schema. staticmethod _format_schema(schema: dict, **kwargs) -> dict Format response schema placeholders with given key-word arguments.","title":"Exceptions"},{"location":"exceptions/#exceptions","text":"Pre-defined authentication and authorization exceptions.","title":"Exceptions"},{"location":"exceptions/#authrequiredexception","text":"aegis.exceptions.AuthRequiredException Raise exception if user tries to reach to a protected route without credentials. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import AuthRequiredException schema = AuthRequiredException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#AuthRequiredException\" , \"title\" : \"Authentication Required\" , \"detail\" : \"You did not specify the required token information in headers or you provided it incorrectly.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" }","title":"AuthRequiredException"},{"location":"exceptions/#invalidtokenexception","text":"aegis.exceptions.InvalidTokenException Raise exception if user uses an invalid access token. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import InvalidTokenException schema = InvalidTokenException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#InvalidTokenException\" , \"title\" : \"Invalid Token\" , \"detail\" : \"You have provided an invalid token signature.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" }","title":"InvalidTokenException"},{"location":"exceptions/#tokenexpiredexception","text":"aegis.exceptions.TokenExpiredException Raise exception if user uses an expired access token. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import TokenExpiredException schema = TokenExpiredException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#TokenExpiredException\" , \"title\" : \"Invalid Token\" , \"detail\" : \"The access token provided has expired.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" }","title":"TokenExpiredException"},{"location":"exceptions/#invalidrefreshtokenexception","text":"aegis.exceptions.InvalidRefreshTokenException Raise exception if user uses an invalid refresh token. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import InvalidRefreshTokenException schema = InvalidRefreshTokenException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#InvalidRefreshTokenException\" , \"title\" : \"Invalid Token\" , \"detail\" : \"You have provided an invalid refresh token.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" }","title":"InvalidRefreshTokenException"},{"location":"exceptions/#authenticationfailedexception","text":"aegis.exceptions.AuthenticationFailedException Raise exception if user tries to authenticate with invalid credentials. Attributes : status: 401 - Exception will create an UNAUTHORIZED response. Methods : staticmethod get_schema() -> dict from aegis import AuthenticationFailedException schema = AuthenticationFailedException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#AuthenticationFailedException\" , \"title\" : \"Authentication Failed\" , \"detail\" : \"The credentials you supplied were not correct.\" , \"instance\" : \" {url} \" , \"status\" : \"401\" }","title":"AuthenticationFailedException"},{"location":"exceptions/#forbiddenexception","text":"aegis.exceptions.ForbiddenException Raise exception if user tries to reach to an end-point without permissions. Attributes : status: 403 - Exception will create an FORBIDDEN response. Methods : staticmethod get_schema() -> dict from aegis import ForbiddenException schema = ForbiddenException . get_schema () assert schema == { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#ForbiddenException\" , \"title\" : \"Forbidden Access\" , \"detail\" : \"User permissions does not meet access requests for {url} \" , \"instance\" : \" {url} \" , \"status\" : \"403\" }","title":"ForbiddenException"},{"location":"exceptions/#authexception","text":"aegis.exceptions.AuthException Base authentication exception. It is not recommended create instances directly from AuthException . Instead, inherit from AuthException and override status code and get_schema method for understandable responses. User should never instantiate the class but create a new class that inherits and overrides required variables and methods. user_id , password and authenticate is forced to override. Attributes : status: int - The HTTP status code that will be used when the error response is sent. Methods : classmethod make_response(cls, request: web.Request) Create a response based on exception schema. staticmethod get_schema() -> dict Return response payload schema. staticmethod _format_schema(schema: dict, **kwargs) -> dict Format response schema placeholders with given key-word arguments.","title":"AuthException"},{"location":"intro/","text":"Introduction Rationale The main motivation for the development of this project was to create an easy-to-use, standards-compliant authentication library with comprehensive documentation and code samples.","title":"Intro"},{"location":"intro/#introduction","text":"","title":"Introduction"},{"location":"intro/#rationale","text":"The main motivation for the development of this project was to create an easy-to-use, standards-compliant authentication library with comprehensive documentation and code samples.","title":"Rationale"},{"location":"middlewares/","text":"Middlewares auth_middleware aegis.middlewares.auth_middleware auth_middleware(request: web.Request, handler: Callable) -> web.Response Decodes the access token and injects the user into the request object. It also handles authentication exceptions. This middleware is designed for use in the interior parts of the library and has nothing to do in the user space.","title":"Middlewares"},{"location":"middlewares/#middlewares","text":"","title":"Middlewares"},{"location":"middlewares/#auth_middleware","text":"aegis.middlewares.auth_middleware auth_middleware(request: web.Request, handler: Callable) -> web.Response Decodes the access token and injects the user into the request object. It also handles authentication exceptions. This middleware is designed for use in the interior parts of the library and has nothing to do in the user space.","title":"auth_middleware"},{"location":"quickstart/","text":"Quickstart In this page, we will explore how we can access and authorize a user in the database using aegis. Installation pip install aegis Simple example The library API is pretty minimalistic: create an authenticator, implement authentication logic, decorate routes. Create an authenticator: from aegis import JWTAuth class JWTAuthenticator ( JWTAuth ): jwt_secret = \"<secret>\" async def authenticate ( self , request : web . Request ) -> dict : ... Implement the authentication logic: async def authenticate ( self , request : web . Request ) -> dict : # You can get the request payload of the /auth route payload = await request . json () # Assuming the name parameter send in the request payload searched_name = payload [ \"name\" ] # fetch the user from your storage db = request . app [ \"db\" ] user = db . get ( searched_name , None ) # return the JSON serializable user return user Decorate route: @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) Let's collect it altogether into very small but still functional example: from aiohttp import web from aegis import login_required , JWTAuth class JWTAuthenticator ( JWTAuth ): jwt_secret = \"<secret>\" async def authenticate ( self , request : web . Request ) -> dict : # You can get the request payload of the /auth route payload = await request . json () # Assuming the name parameter sent in the request payload searched_name = payload [ \"name\" ] # fetch the user from your storage db = request . app [ \"db\" ] user = db . get ( searched_name , None ) # return the JSON serializable user return user @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) app = web . Application () DATABASE = { 'david' : { 'id' : 5 } } app [ \"db\" ] = DATABASE app . router . add_get ( '/' , protected ) JWTAuthenticator . setup ( app ) web . run_app ( app ) We can now navigate to http://0.0.0.0:8080 to check whether its protected or not. In order to get to the route. We first need to get an access token . We can do it by sending the required credentials to the pre-defined `/auth/ route. Authentication request: curl -X POST http://0.0.0.0:8080/auth -d '{ \"name\": \"david\" }' If everything goes OK we will get the access_token as response. { \"access_token\" : \"eyJ...\" } Otherwise we will get one of the pre-defined UNAUTHORIZED responses: { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#AuthenticationFailedException\" , \"title\" : \"Authentication Failed\" , \"detail\" : \"The credentials you supplied were not correct.\" , \"instance\" : \"http://0.0.0.0:8080/auth\" , \"status\" : \"401\" } We can use the access token to reach to the protected route: curl http://0.0.0.0:8080/ -H 'Authorization: Bearer eyJ...' { \"hello\" : \"user\" } That's pretty much it.`","title":"Quick Start"},{"location":"quickstart/#quickstart","text":"In this page, we will explore how we can access and authorize a user in the database using aegis.","title":"Quickstart"},{"location":"quickstart/#installation","text":"pip install aegis","title":"Installation"},{"location":"quickstart/#simple-example","text":"The library API is pretty minimalistic: create an authenticator, implement authentication logic, decorate routes. Create an authenticator: from aegis import JWTAuth class JWTAuthenticator ( JWTAuth ): jwt_secret = \"<secret>\" async def authenticate ( self , request : web . Request ) -> dict : ... Implement the authentication logic: async def authenticate ( self , request : web . Request ) -> dict : # You can get the request payload of the /auth route payload = await request . json () # Assuming the name parameter send in the request payload searched_name = payload [ \"name\" ] # fetch the user from your storage db = request . app [ \"db\" ] user = db . get ( searched_name , None ) # return the JSON serializable user return user Decorate route: @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) Let's collect it altogether into very small but still functional example: from aiohttp import web from aegis import login_required , JWTAuth class JWTAuthenticator ( JWTAuth ): jwt_secret = \"<secret>\" async def authenticate ( self , request : web . Request ) -> dict : # You can get the request payload of the /auth route payload = await request . json () # Assuming the name parameter sent in the request payload searched_name = payload [ \"name\" ] # fetch the user from your storage db = request . app [ \"db\" ] user = db . get ( searched_name , None ) # return the JSON serializable user return user @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) app = web . Application () DATABASE = { 'david' : { 'id' : 5 } } app [ \"db\" ] = DATABASE app . router . add_get ( '/' , protected ) JWTAuthenticator . setup ( app ) web . run_app ( app ) We can now navigate to http://0.0.0.0:8080 to check whether its protected or not. In order to get to the route. We first need to get an access token . We can do it by sending the required credentials to the pre-defined `/auth/ route. Authentication request: curl -X POST http://0.0.0.0:8080/auth -d '{ \"name\": \"david\" }' If everything goes OK we will get the access_token as response. { \"access_token\" : \"eyJ...\" } Otherwise we will get one of the pre-defined UNAUTHORIZED responses: { \"type\" : \"https://mgurdal.github.io/aegis/exceptions/#AuthenticationFailedException\" , \"title\" : \"Authentication Failed\" , \"detail\" : \"The credentials you supplied were not correct.\" , \"instance\" : \"http://0.0.0.0:8080/auth\" , \"status\" : \"401\" } We can use the access token to reach to the protected route: curl http://0.0.0.0:8080/ -H 'Authorization: Bearer eyJ...' { \"hello\" : \"user\" } That's pretty much it.`","title":"Simple example"},{"location":"routes/","text":"Routes aegis has built-in authentication and user routes to save your time. Authentication Route aegis.routes.make_auth_route This function sets-up the /auth/ route which uses authenticator.authenticate() to generate an access token for the user. credentials = { \"username\" : \"test\" , \"password\" : \"test\" } token_response = await session . post ( \"http://0.0.0.0:8080/auth\" , json = credentials ) assert token_response . status == 200 token_payload = await token_response . json () assert token_payload == { \"access_token\" : \"Bearer token\" , } If user enables refresh token, returns the refresh token with the access token. credentials = { \"username\" : \"test\" , \"password\" : \"test\" } token_response = await session . post ( \"http://0.0.0.0:8080/auth\" , json = credentials ) assert token_response . status == 200 token_payload = await token_response . json () assert token_payload == { \"access_token\" : \"Bearer token\" , \"refresh_token\" : \"refresh_token\" } If authenticate returns None or raises AuthException returns an authorization failing response based on the condition. credentials = { \"username\" : \"test\" , \"password\" : \"test\" } token_response = await session . post ( \"http://0.0.0.0:8080/auth\" , json = credentials ) assert token_response . status == 401 error = await token_response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#AuthenticationFailedException\" , \"title\" : \"Authentication Failed\" , \"detail\" : \"The credentials you supplied were not correct.\" , \"instance\" : \"http://0.0.0.0:8080/auth\" , \"status\" : \"401\" } Me Route aegis.routes.make_me_route Shown authenticated user's information. Returns the user if user is authenticated. user_response = await session . get ( \"http://0.0.0.0:8080/me\" ) assert user_response . status == 200 user = await user_response . json () assert user == { \"id\" : 1 , \"permissions\" : [ \"user\" ], \"exp\" : 1212.121 } Returns UNAUTHORIZED response if user is not authenticated. error_response = await session . get ( \"http://0.0.0.0:8080/me\" ) assert error_response . status == 401 error = await error_response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#AuthRequiredException\" , \"title\" : \"Authentication Required\" , \"detail\" : \"You did not specify the required token information in headers or you provided it incorrectly.\" , \"instance\" : \"http://0.0.0.0:8080/me\" , \"status\" : \"401\" } Refresh Route aegis.routes.make_refresh_route Retrieve a new access token with the refresh token. Returns the user if user is authenticated. refresh_payload = { \"refresh_token\" : \"ec597c581c09466badd8376b56102052\" } access_token_response = await session . post ( \"http://0.0.0.0:8080/auth/refresh\" , json = refresh_payload ) assert access_token_response . status == 200 token_payload = await access_token_response . json () assert token_payload == { \"access_token\" : \"Bearer token..\" } Returns UNAUTHORIZED response if refresh token is invalid. refresh_payload = { \"refresh_token\" : \"Invalid refresh token\" } error_response = await session . post ( \"http://0.0.0.0:8080/auth/refresh\" , json = refresh_payload ) assert error_response . status == 401 error = await error_response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#InvalidRefreshTokenException\" , \"title\" : \"Invalid Token\" , \"detail\" : \"You have provided an invalid refresh token.\" , \"instance\" : \"http://0.0.0.0:8080/auth/refresh\" , \"status\" : \"401\" }","title":"Routes"},{"location":"routes/#routes","text":"aegis has built-in authentication and user routes to save your time.","title":"Routes"},{"location":"routes/#authentication-route","text":"aegis.routes.make_auth_route This function sets-up the /auth/ route which uses authenticator.authenticate() to generate an access token for the user. credentials = { \"username\" : \"test\" , \"password\" : \"test\" } token_response = await session . post ( \"http://0.0.0.0:8080/auth\" , json = credentials ) assert token_response . status == 200 token_payload = await token_response . json () assert token_payload == { \"access_token\" : \"Bearer token\" , } If user enables refresh token, returns the refresh token with the access token. credentials = { \"username\" : \"test\" , \"password\" : \"test\" } token_response = await session . post ( \"http://0.0.0.0:8080/auth\" , json = credentials ) assert token_response . status == 200 token_payload = await token_response . json () assert token_payload == { \"access_token\" : \"Bearer token\" , \"refresh_token\" : \"refresh_token\" } If authenticate returns None or raises AuthException returns an authorization failing response based on the condition. credentials = { \"username\" : \"test\" , \"password\" : \"test\" } token_response = await session . post ( \"http://0.0.0.0:8080/auth\" , json = credentials ) assert token_response . status == 401 error = await token_response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#AuthenticationFailedException\" , \"title\" : \"Authentication Failed\" , \"detail\" : \"The credentials you supplied were not correct.\" , \"instance\" : \"http://0.0.0.0:8080/auth\" , \"status\" : \"401\" }","title":"Authentication Route"},{"location":"routes/#me-route","text":"aegis.routes.make_me_route Shown authenticated user's information. Returns the user if user is authenticated. user_response = await session . get ( \"http://0.0.0.0:8080/me\" ) assert user_response . status == 200 user = await user_response . json () assert user == { \"id\" : 1 , \"permissions\" : [ \"user\" ], \"exp\" : 1212.121 } Returns UNAUTHORIZED response if user is not authenticated. error_response = await session . get ( \"http://0.0.0.0:8080/me\" ) assert error_response . status == 401 error = await error_response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#AuthRequiredException\" , \"title\" : \"Authentication Required\" , \"detail\" : \"You did not specify the required token information in headers or you provided it incorrectly.\" , \"instance\" : \"http://0.0.0.0:8080/me\" , \"status\" : \"401\" }","title":"Me Route"},{"location":"routes/#refresh-route","text":"aegis.routes.make_refresh_route Retrieve a new access token with the refresh token. Returns the user if user is authenticated. refresh_payload = { \"refresh_token\" : \"ec597c581c09466badd8376b56102052\" } access_token_response = await session . post ( \"http://0.0.0.0:8080/auth/refresh\" , json = refresh_payload ) assert access_token_response . status == 200 token_payload = await access_token_response . json () assert token_payload == { \"access_token\" : \"Bearer token..\" } Returns UNAUTHORIZED response if refresh token is invalid. refresh_payload = { \"refresh_token\" : \"Invalid refresh token\" } error_response = await session . post ( \"http://0.0.0.0:8080/auth/refresh\" , json = refresh_payload ) assert error_response . status == 401 error = await error_response . json () assert error == { \"type\" : \"https://mgurdal.github.io/aegis/api.html#InvalidRefreshTokenException\" , \"title\" : \"Invalid Token\" , \"detail\" : \"You have provided an invalid refresh token.\" , \"instance\" : \"http://0.0.0.0:8080/auth/refresh\" , \"status\" : \"401\" }","title":"Refresh Route"},{"location":"testing/","text":"Testing Testing can be really tricky if a library adds bunch of middle-wares and decorators in your application. However, aegis includes some testing utilities to help you to have better control in your application state. Lets dive into some code! First, we will create a really simple app with an authentication logic in it. In this example, user will never be able to reach to the \"/\" endpoint. # examples/testing/app.py from aiohttp import web from aegis import login_required , BasicAuth class BasicAuthenticator ( BasicAuth ): async def authenticate ( self , request : web . Request ) -> dict : pass @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) def create_app (): app = web . Application () app . router . add_get ( '/' , protected ) BasicAuthenticator . setup ( app ) return app if __name__ == \"__main__\" : app = create_app () web . run_app ( app ) Now, lets write some test to get the authentication error response. We will define our test case by inheriting from aiohttp's AioHTTPTestCase and overriding the get_application method. # examples/testing/test_app.py from aiohttp.test_utils import AioHTTPTestCase # import the app factory from app import create_app class AppTestCase ( AioHTTPTestCase ): async def get_application ( self ): app = create_app () return app Next, we will create a test method that sends a get request to the protected / route and validates the response's status code. @unittest_run_loop async def test_protected_route_without_credentials ( self ): # AioHTTPTestCase provides us a client to send requests. resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 200 If we run this with pytest, it will fail with this message. =================================== FAILURES =================================== _______________ AppTestCase . test_protected_route_without_credentials _______________ self = < test_app . AppTestCase testMethod = test_protected_route_without_credentials > @unittest_run_loop async def test_protected_route_without_credentials ( self ) : resp = await self . client . request ( \"GET\" , \"/\" ) > assert resp . status == 200 E AssertionError : assert 401 == 200 E + where 401 = < ClientResponse ( http : // 127.0.0.1 : 59273 / ) [ 401 Unauthorized ]> \\ n < CIMultiDictProxy ( 'Content-Type' : 'application/json; charset=utf-8' , 'Content-Length' : '276' , 'Date' : 'Mon, 06 May 2019 22:50:50 GMT' , 'Server' : 'Python/3.7 aiohttp/3.5.4' ) > \\ n . status Since this application does not use any real authentication logic. We have to bypass the authentication system completely. To do this, We need to mock our authenticator with aegis.test_utils.MockAuthenticator . We can do it by simply calling the MockAuthenticator.setup method with our \u00e0pp instance. class AppTestCase ( AioHTTPTestCase ): async def get_application ( self ): app = create_app () MockAuthenticator . setup ( app ) return app By calling the setup method, MockAuthenticator will mock the BasicAuthenticator that we have been using in our app. MockAuthenticator is almost the same with our previous authenticator, in addition to that, it also has some extra features to help us to bypass the authentication system. bypass_auth(user) We only need the bypass_auth method to control the authentication logic. It is a contextmanager . So you can disable the permission control multiple times in your test suite. To use the bypass_auth , we first need to reach to our mocked authenticator. And then, we can control the authentication by calling the mocked_authenticator.bypass_auth method with a test user. @unittest_run_loop async def test_protected_route_without_credentials ( self ): mocked_authenticator = self . app [ \"authenticator\" ] mock_user = { \"permissions\" : ( \"user\" ,)} with mocked_authenticator . bypass_auth ( user = mock_user ): resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 200 resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 401 Have fun!","title":"Testing"},{"location":"testing/#testing","text":"Testing can be really tricky if a library adds bunch of middle-wares and decorators in your application. However, aegis includes some testing utilities to help you to have better control in your application state. Lets dive into some code! First, we will create a really simple app with an authentication logic in it. In this example, user will never be able to reach to the \"/\" endpoint. # examples/testing/app.py from aiohttp import web from aegis import login_required , BasicAuth class BasicAuthenticator ( BasicAuth ): async def authenticate ( self , request : web . Request ) -> dict : pass @login_required async def protected ( request ): return web . json_response ({ 'hello' : 'user' }) def create_app (): app = web . Application () app . router . add_get ( '/' , protected ) BasicAuthenticator . setup ( app ) return app if __name__ == \"__main__\" : app = create_app () web . run_app ( app ) Now, lets write some test to get the authentication error response. We will define our test case by inheriting from aiohttp's AioHTTPTestCase and overriding the get_application method. # examples/testing/test_app.py from aiohttp.test_utils import AioHTTPTestCase # import the app factory from app import create_app class AppTestCase ( AioHTTPTestCase ): async def get_application ( self ): app = create_app () return app Next, we will create a test method that sends a get request to the protected / route and validates the response's status code. @unittest_run_loop async def test_protected_route_without_credentials ( self ): # AioHTTPTestCase provides us a client to send requests. resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 200 If we run this with pytest, it will fail with this message. =================================== FAILURES =================================== _______________ AppTestCase . test_protected_route_without_credentials _______________ self = < test_app . AppTestCase testMethod = test_protected_route_without_credentials > @unittest_run_loop async def test_protected_route_without_credentials ( self ) : resp = await self . client . request ( \"GET\" , \"/\" ) > assert resp . status == 200 E AssertionError : assert 401 == 200 E + where 401 = < ClientResponse ( http : // 127.0.0.1 : 59273 / ) [ 401 Unauthorized ]> \\ n < CIMultiDictProxy ( 'Content-Type' : 'application/json; charset=utf-8' , 'Content-Length' : '276' , 'Date' : 'Mon, 06 May 2019 22:50:50 GMT' , 'Server' : 'Python/3.7 aiohttp/3.5.4' ) > \\ n . status Since this application does not use any real authentication logic. We have to bypass the authentication system completely. To do this, We need to mock our authenticator with aegis.test_utils.MockAuthenticator . We can do it by simply calling the MockAuthenticator.setup method with our \u00e0pp instance. class AppTestCase ( AioHTTPTestCase ): async def get_application ( self ): app = create_app () MockAuthenticator . setup ( app ) return app By calling the setup method, MockAuthenticator will mock the BasicAuthenticator that we have been using in our app. MockAuthenticator is almost the same with our previous authenticator, in addition to that, it also has some extra features to help us to bypass the authentication system.","title":"Testing"},{"location":"testing/#bypass_authuser","text":"We only need the bypass_auth method to control the authentication logic. It is a contextmanager . So you can disable the permission control multiple times in your test suite. To use the bypass_auth , we first need to reach to our mocked authenticator. And then, we can control the authentication by calling the mocked_authenticator.bypass_auth method with a test user. @unittest_run_loop async def test_protected_route_without_credentials ( self ): mocked_authenticator = self . app [ \"authenticator\" ] mock_user = { \"permissions\" : ( \"user\" ,)} with mocked_authenticator . bypass_auth ( user = mock_user ): resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 200 resp = await self . client . request ( \"GET\" , \"/\" ) assert resp . status == 401 Have fun!","title":"bypass_auth(user)"}]}